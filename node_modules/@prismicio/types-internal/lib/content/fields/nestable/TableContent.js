"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseTableContent = exports.TableLegacy = exports.TableContent = exports.isTableContent = exports.TableContentType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const customtypes_1 = require("../../../customtypes");
const utils_1 = require("../../utils");
const RichTextContent_1 = require("./RichTextContent");
exports.TableContentType = "TableContent";
const isTableContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.TableContentType;
exports.isTableContent = isTableContent;
const TableCell = (0, utils_1.withKey)(t.intersection([
    t.strict({
        type: t.union([t.literal("tableHeader"), t.literal("tableCell")]),
        content: RichTextContent_1.RichTextContent,
    }),
    t.exact(t.partial({
        columnWidth: t.number,
    })),
]));
const TableRow = (0, utils_1.withKey)(t.strict({
    type: t.literal("tableRow"),
    content: t.array(TableCell),
}));
exports.TableContent = t.strict({
    __TYPE__: t.literal(exports.TableContentType),
    content: t.array(TableRow),
});
// Legacy.
const TableCellLegacy = (0, utils_1.withKey)(t.intersection([
    t.strict({
        type: t.union([t.literal("tableHeader"), t.literal("tableCell")]),
        content: RichTextContent_1.RichTextLegacyContent,
    }),
    t.exact(t.partial({
        columnWidth: t.number,
    })),
]));
const TableRowLegacy = (0, utils_1.withKey)(t.strict({
    type: t.literal("tableRow"),
    content: t.array(TableCellLegacy),
}));
const TableLegacyContent = t.strict({
    content: t.array(TableRowLegacy),
});
const TableLegacy = (ctx) => new t.Type("TableLegacy", exports.isTableContent, (u) => {
    return (0, function_1.pipe)(TableLegacyContent.decode(u), fp_ts_1.either.map((content) => ({
        __TYPE__: "TableContent",
        content: content.content.map((row) => ({
            ...row,
            content: row.content.map((cell) => ({
                ...cell,
                content: {
                    __TYPE__: "StructuredTextContent",
                    value: cell.content,
                },
            })),
        })),
    })));
}, (t) => {
    return {
        content: TableLegacyContent.encode({
            content: t.content.map((row) => ({
                ...row,
                content: row.content.map((cell) => ({
                    ...cell,
                    content: cell.content.value,
                })),
            })),
        }),
        types: { [ctx.keyOfType]: "Table" },
    };
});
exports.TableLegacy = TableLegacy;
// Traverse.
function traverseTableContent({ path, key, apiId, model, content, }) {
    return (transform) => {
        const tableContent = content.content.map((row, rowIndex) => ({
            ...row,
            content: row.content.map((cell, cellIndex) => {
                const itemPath = path.concat([
                    {
                        key: [rowIndex.toString(), cellIndex.toString()].join(","),
                        type: "Widget",
                    },
                ]);
                const cellContent = transform({
                    path: itemPath,
                    key,
                    apiId,
                    model: customtypes_1.TableCell,
                    content: {
                        __TYPE__: cell.content.__TYPE__,
                        value: cell.content.value,
                    },
                }) || {
                    __TYPE__: "StructuredTextContent",
                    value: [],
                }; // Return an empty table cell if the transform function filters out rich text (returns undefined)
                return {
                    ...cell,
                    content: cellContent,
                };
            }),
        }));
        return transform({
            path,
            key,
            apiId,
            model,
            content: {
                __TYPE__: content.__TYPE__,
                content: tableContent,
            },
        });
    };
}
exports.traverseTableContent = traverseTableContent;
